- Logistics
  - Will seek possible support from Intel, Amazon, MS, Google, others?
  - Formally plan to make this a student-run organization
  - Logistics: Monday 6-7 (?)
  - Format: Tutorial/discussion + lightning talks
  - Goal is to get this self-sustaining by the end of academic year
- Organizational models for learning about software
  - <http://www.thehackerwithin.org/>
  - <https://science.mozilla.org/>
  - Courses, bootcamps, meetups, and communities of practice
- Cornell resources for scientific computing
  - CAC, CIT, RDMSG, and other groups
  - Local courses and workshops
  - Student-run tutorials
- Version control
  - Git, Mercurial, Subversion, and company
  - Hosted services: GitHub, Bitbucket, Assembla, etc
  - Cornell-local options: GitHub Enterprise, Sourceforge
  - What to control?  Issues with built artifacts and large data
  - Locks, pull requests, and collaboration with version control
- At the terminal
  - Local and remote terminals
  - Windows: Cygwin, MinGW, and Linux in Windows 10
  - SSH keys and password-free operation
  - screen, tmux, and other terminal multiplexing options
  - Terminal sharing with tmate
- Language environments and tooling
  - "Just enough" introductions: Bash, Python, MATLAB, Julia, R
  - Issues in high-performance scripting
  - Using Jupyter notebooks
- Workflow automation and documentation
  - Make, Rake, SnakeMake, etc
  - Pipelines and notebooks
  - Reproducibility
  - Continuous integration environments (Bamboo, Jenkins, TravisCI, etc)
- Getting computing resources for scientific computing
  - Overview: Servers, clusters, clouds, supercomputers
  - Cornell-local resources
  - Supercomputing resources
  - Cloud resources
- Scientific computing in the cloud
  - Working with EC2, GCP, and Azure (try to get industry tutorials?)
  - RedCloud (get CAC tutorial?)
  - Accelerators, Infiniband, and other specialized support
- Environment virtualization
  - Virtual machines
  - Docker and containers
  - Language level: Python virtualenv and conda
- Reproducibility issues
  - Reproducibility best practices
  - Special issues with reproducibility and high-performance computing
- Build and configuration
  - "The build problem": survey and history
  - Autotools, CMake, SCons, etc
- Packaging and distribution
  - Semantic versioning
  - Automating distribution
  - Packaging of compiled codes
  - Packaging in Python, Julia, R
  - Software licensing and copyright issues
- Documentation
  - Javadoc, Doxygen, Sphinx, and other tools
  - Plain-text formats: RESt, Markdown, LaTeX
  - Pandoc
  - Literate programming
- Data management
  - "Just enough" SQL
  - HDF5, NetCDF, and related formats
  - XML, YAML, JSON, metadata, and semi-structured data
  - Facilities for large-scale working data
  - Data set archival
- Plotting and visualization
  - Matplotlib, Seaborn, GNUPlot, D3, etc
  - Visualization of network data
  - Simulation visualization with VisIt and Paraview
  - XTK
- Testing and company
  - Linting code
  - Code reviews and tools
  - Valgrind and company
  - Types of tests: unit, integration, regression, etc
  - Test-driven development
  - Tooling for test automation
  - Continuous integration tools and services
  - Tickets and bug databases
  - Special issues in testing of numerical codes
- Monitoring and checkpointing
  - Assertions and exceptions
  - Logging systems
  - Automated checkpoints
  - Application-level checkpointing
- Tuning
  - "Just enough" computer architecture
  - Profiling for scripts and compiled codes
  - Profile-guided optimization
  - Sources for tuned libraries
  - Accelerator-aided libraries
  - Software modernization resources
- Mixed language programming
  - Models: script-driven, embedded scripting, configuration languages,
    cross-language library calls, code generation
  - Interface generators
  - Function calls vs inter-process communication
  - Build-time issues: portability, standard libraries, linkage
- Fast math frameworks and libraries
  - PETSc, Trilinos, SuperLU, etc
  - ACTS framework
